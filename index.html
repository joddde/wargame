<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Text-Based Game</title>
  <style>
    :root {
      --bg: #000;
      --fg: #00ff65;
      --dim: #00c04e;
      --danger: #ff4d4d;
      --overlay: rgba(0, 0, 0, 0.8);
      --panel: #0f0f0f;
      --border: #1f1f1f;
      --accent: #00ff9c;
    }

    body {
      background-color: var(--bg);
      color: var(--fg);
      font-family: 'Courier New', Courier, monospace;
      padding: 20px;
      margin: 0;
    }

    #game {
      white-space: normal;
      line-height: 1.4;
    }

    .line {
      margin: 4px 0;
    }

    .inline-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 10px;
      margin: 6px 0 12px;
      align-items: flex-start;
    }

    .inline-list .item {
      display: inline-block;
      padding: 2px 6px;
      border: 1px solid var(--border);
      background: #0b0b0b;
      color: var(--fg);
      border-radius: 3px;
      white-space: nowrap;
      font-size: 14px;
    }

    .inline-list.countdown .item {
      color: var(--dim);
      border-style: dashed;
      font-size: 12px;
      padding: 1px 6px;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: var(--overlay);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal {
      width: min(520px, 92vw);
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: 0 0 0 2px #003b1f inset, 0 10px 30px rgba(0, 0, 0, 0.6);
      border-radius: 6px;
      overflow: hidden;
      color: var(--fg);
    }

    .modal__header {
      padding: 10px 14px;
      background: #061d11;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal__title {
      font-weight: bold;
      letter-spacing: 0.5px;
      color: var(--accent);
    }

    .modal__close {
      color: var(--fg);
      background: transparent;
      border: none;
      font-size: 18px;
      cursor: pointer;
      line-height: 1;
    }

    .modal__body {
      padding: 16px 14px 6px;
    }

    .modal__message {
      margin: 0 0 10px 0;
      color: var(--fg);
      min-height: 1.2em;
      white-space: pre-wrap;
    }

    .modal__input {
      width: 100%;
      background: #0b0b0b;
      color: var(--fg);
      border: 1px solid var(--border);
      padding: 10px 12px;
      border-radius: 4px;
      font-family: inherit;
      font-size: 16px;
      outline: none;
    }

    .modal__input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 255, 156, 0.2);
    }

    .modal__error {
      color: var(--danger);
      margin-top: 8px;
      min-height: 1.2em;
    }

    .modal__footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      padding: 12px 14px 14px;
      border-top: 1px solid var(--border);
    }

    .btn {
      appearance: none;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
      letter-spacing: 0.4px;
      border-radius: 4px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: #0b0b0b;
      color: var(--fg);
    }

    .btn--primary {
      border-color: #015c38;
      background: #06261a;
      color: var(--accent);
    }

    .btn:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #game::after {
      content: "â–‹";
      margin-left: 6px;
      animation: blink 1.1s steps(2, start) infinite;
      color: var(--dim);
    }
    @keyframes blink {
      to { visibility: hidden; }
    }
  </style>
</head>
<body>
  <div id="game" aria-live="polite"></div>

  <div class="modal-overlay" id="modalOverlay" aria-modal="true" role="dialog" aria-labelledby="modalTitle">
    <div class="modal">
      <div class="modal__header">
        <div class="modal__title" id="modalTitle">SYSTEM QUERY</div>
        <button class="modal__close" id="modalCloseBtn" aria-label="Cancel (Esc)">&times;</button>
      </div>
      <div class="modal__body">
        <p class="modal__message" id="modalMessage"></p>
        <input type="text" class="modal__input" id="modalInput" placeholder="" />
        <div class="modal__error" id="modalError" aria-live="assertive"></div>
      </div>
      <div class="modal__footer">
        <button class="btn" id="modalCancel">Cancel (Esc)</button>
        <button class="btn btn--primary" id="modalOk">OK (Enter)</button>
      </div>
    </div>
  </div>

  <script>
    const gameElement = document.getElementById('game');

    /* ============================================================
       TypeClick: WebAudio "key click" generator
       - Short square-wave burst with envelope and downward sweep
       - Skips sounds for elements inside countdown/timer/silent zones
       ============================================================ */
    const TypeClick = (() => {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioCtx();
      let enabled = false;
      let minGap = 28;   // ms between clicks to avoid audio spam
      let lastAt = 0;

      // Unlock on user gesture (autoplay policy)
      const unlock = () => { enabled = true; if (ctx.state === 'suspended') ctx.resume(); };
      window.addEventListener('pointerdown', unlock, { once: true });
      window.addEventListener('keydown', unlock, { once: true });

      function isSilent(el) {
        return !!(el && el.closest('.countdown, .timer, .no-sound, [data-silent="true"]'));
      }

      function play(forEl) {
        if (!enabled) return;
        if (isSilent(forEl)) return;

        const now = performance.now();
        if (now - lastAt < minGap) return;
        lastAt = now;

        const t = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = 'square';
        osc.frequency.setValueAtTime(2400, t);
        osc.frequency.exponentialRampToValueAtTime(1600, t + 0.04);

        gain.gain.setValueAtTime(0.0001, t);
        gain.gain.linearRampToValueAtTime(0.35, t + 0.002);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.045);

        osc.connect(gain).connect(ctx.destination);
        osc.start(t);
        osc.stop(t + 0.05);
      }

      return { play, setMinGap(ms){ minGap=Math.max(0, ms|0);} };
    })();

    const WORLD_POP = 8_000_000_000;
    const LETHALITY_K = 0.08;
    const SURVIVOR_FLOOR = 1_000_000;

    function formatNumber(n) {
      try { return n.toLocaleString(); } catch { return String(n); }
    }

    function survivorsFromMissiles(totalMissiles) {
      const est = Math.round(WORLD_POP * Math.exp(-LETHALITY_K * totalMissiles));
      return Math.max(est, SURVIVOR_FLOOR);
    }

    function scrollToBottom() {
      window.requestAnimationFrame(() => {
        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
      });
    }

    /* ============================================================
       Type text into an element with sound
       ============================================================ */
    async function typeText(el, text, { charDelay = 45, soundEvery = 1 } = {}) {
      el.textContent = '';
      for (let i = 0; i < text.length; i++) {
        el.textContent += text[i];
        if (i % soundEvery === 0) TypeClick.play(el);
        scrollToBottom();
        // tiny delay for natural pacing; keep short so game timing feels snappy
        await new Promise(r => setTimeout(r, charDelay));
      }
    }

    function displayMessage(message) {
      // Typed message with click per character
      const line = document.createElement('div');
      line.className = 'line';
      gameElement.appendChild(line);
      scrollToBottom();
      // fire-and-forget typing (doesn't block game timers/logic)
      typeText(line, message, { charDelay: 35, soundEvery: 1 });
    }

    // NEW: Add cities to list with a delay between each (.1s per city)
    async function addInlineListWithDelay(items, extraClass = '') {
      const list = document.createElement('div');
      list.className = `inline-list ${extraClass}`.trim();
      gameElement.appendChild(list);
      scrollToBottom();
      const isCountdown = list.classList.contains('countdown');
      for (const txt of items) {
        await new Promise(res => setTimeout(res, 100));
        const span = document.createElement('span');
        span.className = 'item';
        span.textContent = txt;
        list.appendChild(span);
        // Play click for each revealed item unless this is a countdown/timer list
        if (!isCountdown) TypeClick.play(span);
        scrollToBottom();
      }
      return list;
    }

    function addInlineList(items, extraClass = '') {
      // Original, immediate version for countdown and other uses
      const list = document.createElement('div');
      list.className = `inline-list ${extraClass}`.trim();
      for (const txt of items) {
        const span = document.createElement('span');
        span.className = 'item';
        span.textContent = txt;
        list.appendChild(span);
      }
      gameElement.appendChild(list);
      scrollToBottom();
      return list;
    }

    function askQuestion(message, { placeholder = '', validate = null } = {}) {
      return new Promise((resolve) => {
        const overlay = document.getElementById('modalOverlay');
        const msgEl = document.getElementById('modalMessage');
        const inputEl = document.getElementById('modalInput');
        const errorEl = document.getElementById('modalError');
        const okBtn = document.getElementById('modalOk');
        const cancelBtn = document.getElementById('modalCancel');
        const closeBtn = document.getElementById('modalCloseBtn');

        let settled = false;

        function open() {
          // Type the prompt message with a slightly faster cadence
          msgEl.textContent = '';
          typeText(msgEl, message, { charDelay: 25, soundEvery: 1 }); // non-blocking

          inputEl.value = '';
          inputEl.placeholder = placeholder;
          errorEl.textContent = '';
          overlay.style.display = 'flex';
          setTimeout(() => inputEl.focus(), 0);
          document.addEventListener('keydown', onKey);
          okBtn.addEventListener('click', onOk);
          cancelBtn.addEventListener('click', onCancel);
          closeBtn.addEventListener('click', onCancel);
        }

        function close() {
          overlay.style.display = 'none';
          document.removeEventListener('keydown', onKey);
          okBtn.removeEventListener('click', onOk);
          cancelBtn.removeEventListener('click', onCancel);
          closeBtn.removeEventListener('click', onCancel);
        }

        function onKey(e) {
          if (e.key === 'Enter') onOk();
          if (e.key === 'Escape') onCancel();
        }

        function onOk() {
          if (settled) return;
          const value = inputEl.value.trim();
          if (typeof validate === 'function') {
            const result = validate(value);
            if (result !== true) {
              errorEl.textContent = result || 'Invalid input.';
              return;
            }
          }
          settled = true;
          close();
          resolve(value);
        }

        function onCancel() {
          if (settled) return;
          settled = true;
          close();
          resolve(null);
        }

        open();
      });
    }

    async function startGame() {
      gameElement.innerText = '';
      displayMessage('*** IBM AS400 Terminal ***');

      const playAnswer = await askQuestion(
        'Would you like to play a game? (yes/no)',
        {
          placeholder: 'yes or no',
          validate: (val) => {
            if (!val) return 'Please answer "yes" or "no".';
            const v = val.trim().toLowerCase();
            if (!['y', 'yes', 'n', 'no'].includes(v)) return 'Type "yes" or "no".';
            return true;
          },
        }
      );

      if (playAnswer === null) {
        displayMessage('Session cancelled.');
        displayMessage('Goodbye.');
        return;
      }

      const wantsToPlay = /^y(es)?$/i.test(playAnswer.trim());
      if (!wantsToPlay) {
        displayMessage('Understood. Maybe another time.');
        displayMessage('Session ended.');
        return;
      }

      displayMessage('Initializing scenario...');

      setTimeout(() => {
        displayMessage('China has launched a nuclear missile.');

        setTimeout(() => {
          displayMessage('The missile will hit San Francisco in 25 minutes.');

          setTimeout(async () => {
            const missilesStr = await askQuestion(
              'Do you want to launch nuclear missiles at China? If yes, how many?',
              {
                placeholder: 'Enter a non-negative integer (e.g., 0, 10, 50)',
                validate: (val) => {
                  if (val === '') return 'Please enter a number (0 or more).';
                  const n = Number(val);
                  if (!Number.isInteger(n) || n < 0) return 'Value must be a non-negative integer.';
                  if (n > 50) return 'That is too many for this simulation (max 50).';
                  return true;
                },
              }
            );

            if (missilesStr === null) {
              displayMessage('You cancelled the launch decision.');
              displayMessage('Game Over.');
              return;
            }

            const missiles = Number(missilesStr);
            if (missiles > 0) {
              displayMessage(`You have chosen to launch ${missiles} nuclear missiles at China.`);

              await listCities(missiles);

              countdownToImpact(25, () => {
                const chinaMissiles = missiles * 2;
                displayMessage(`China has launched ${chinaMissiles} nuclear missiles at the USA, Canada, and Mexico.`);

                setTimeout(async () => {
                  displayMessage(`The largest ${chinaMissiles} cities in North America are the targets.`);
                  await displayCities(chinaMissiles);

                  countdownToImpact(20, () => {
                    // ADD 1 to China's missile count for the initial strike
                    const totalMissiles = missiles + chinaMissiles + 1;
                    estimateSurvivors(totalMissiles, { your: missiles, china: chinaMissiles + 1 });
                  });
                }, 2000); // 2 second pause here
              });
            } else {
              displayMessage('You have chosen not to launch any missiles.');
              displayMessage('Game Over.');
            }
          }, 5000);
        }, 5000);
      }, 1000);
    }

    // listCities and displayCities now use addInlineListWithDelay
    async function listCities(missiles) {
      const cities = [
        'Beijing','Shanghai','Guangzhou','Shenzhen','Tianjin','Chongqing','Nanjing','Wuhan','Chengdu',"Xi'an",
        'Pyongyang','Hamhung','Chongjin','Nampo','Wonsan','Sinuiju','Tanchon','Kaechon','Kaesong','Sariwon',
        'Shenyang','Suzhou','Harbin','Qingdao','Dalian','Jinan','Hangzhou','Fuzhou','Zhengzhou','Changsha',
        'Shijiazhuang','ÃœrÃ¼mqi','Ningbo','Taiyuan','Xiamen','Changchun','Kunming','Hefei','Tangshan','Baotou',
        'Yantai','Taiyuan','Luoyang','Handan','Nanchang','Xuzhou','Lanzhou','Huainan','Jilin','Zibo',
        'Hohhot','Yinchuan','Baoji','Anshan','Weifang','Datong','Hengyang','Zhangjiakou','Linyi','Quanzhou',
        'Liaoyang','Jiaozuo','Jiangmen','Shangqiu','Foshan','Dongguan','Maoming','Leshan','Jiujiang','Fuling',
        'Panjin','Shaoyang','Jinzhou','Huangshi','Fuxin','Zhuzhou','Yueyang','Chenzhou','Haikou','Baoding',
        'Bengbu','Jiamusi','Xiangtan','Sanmenxia','Tieling','Yanji','Jingzhou','Yuncheng','Chifeng','Zhangzhou',
        'Yibin','Pingdingshan','Heze','Liaocheng','Jingmen','Yancheng','Yuxi','Mudanjiang','Yangzhou','Wuhu'
      ];
      const output = [];
      for (let i = 0; i < missiles; i++) {
        output.push(cities[i % cities.length]);
      }
      await addInlineListWithDelay(output);
    }

    async function displayCities(number) {
      const cities = [
        'Mexico City','New York City','Los Angeles','Toronto','Chicago','Houston','Havana','Tijuana',
        'Montreal','Phoenix','Ecatepec de Morelos','LeÃ³n','Philadelphia','Puebla','JuÃ¡rez','Zapopan',
        'San Antonio','Calgary','Guadalajara','San Diego','Dallas','Guatemala City','Port-au-Prince',
        'Monterrey','Tegucigalpa','Edmonton','Panama City','NezahualcÃ³yotl','Ottawa','Managua',
        'Santo Domingo','Austin','Jacksonville','San Jose','Fort Worth','Chihuahua','MÃ©rida',
        'Naucalpan','Toluca','Columbus','Charlotte','CancÃºn','Indianapolis','Saltillo','Aguascalientes',
        'Hermosillo','Mexicali','Seattle','Denver','El Paso','Detroit','CuliacÃ¡n','Guadalupe',
        'Acapulco de JuÃ¡rez','Mississauga','Boston','Memphis','Tlalnepantla','New South Memphis',
        'North York','Portland','Winnipeg','Oklahoma City','Santiago de QuerÃ©taro','Las Vegas',
        'Baltimore','CoyoacÃ¡n','Santa MarÃ­a ChimalhuacÃ¡n','TorreÃ³n','Washington, D.C.','Milwaukee',
        'Vancouver','Scarborough','Morelia','Reynosa','New Kingston','Tlaquepaque','Tlalpan',
        'South Boston','Albuquerque','Santiago de Cuba','Tuxtla','CuauhtÃ©moc','Tucson','Nashville',
        'QuÃ©bec','San Salvador','Fresno','Hamilton','Victoria de Durango','Sacramento','San Pedro Sula',
        'Toluca','Ciudad LÃ³pez Mateos','CuautitlÃ¡n Izcalli','St. Louis','Kansas City','Oakland',
        'Minneapolis','San Juan'
      ];
      const output = [];
      for (let i = 0; i < number; i++) {
        output.push(cities[i % cities.length]);
      }
      await addInlineListWithDelay(output);
    }

    function countdownToImpact(minutes, callback) {
      displayMessage('Time until impact (minutes):');
      const list = addInlineList([], 'countdown');

      const interval = setInterval(() => {
        if (minutes > 0) {
          const tick = document.createElement('span');
          tick.className = 'item';
          tick.textContent = String(minutes);
          tick.setAttribute('aria-label', `Time until impact: ${minutes} minutes`);
          list.appendChild(tick);
          // No click here by design: .countdown is a silent zone
          scrollToBottom();
          minutes--;
        } else {
          clearInterval(interval);
          callback();
        }
      }, 500);
    }

    function estimateSurvivors(totalMissiles, breakdown = { your: 0, china: 0 }) {
      displayMessage('Estimating the number of people that will still be alive on Earth one year after the exchange...');
      setTimeout(() => {
        const survivors = survivorsFromMissiles(totalMissiles);
        displayMessage(`Total missiles launched: ${breakdown.your} (you) + ${breakdown.china} (China) = ${totalMissiles}.`);
        displayMessage(`Estimated survivors: ~${formatNumber(survivors)} people.`);
      }, 2000);
    }

    startGame();
  </script>
</body>
</html>
